# TreeForge

This Python program creates directories and files from a tree diagram specified in a text file. It parses the tree structure, including indentation and special characters (<code style="color : darkorange">│</code>, ├, └, ─), and replicates it in a user-specified output directory. The program is useful for quickly setting up project structures based on tree diagrams.

## Features

1. Parses tree diagrams with standard formatting (e.g., generated by the tree command).
2. Creates directories and empty files in the specified output directory.
3. Ignores comments (text following <code style="color : darkorange">#</code>) in the tree diagram to ensure clean file and directory names.
4. Handles nested directories and files with proper indentation-based hierarchy.
5. Command-line interface for easy integration into workflows.

## Installation

1.  **Clone the Repository**:
```bash
git clone https://github.com/ExoduxNile/TreeForge.git
cd TreeForge
```
2.  **Ensure Python 3 is Installed**: The program requires Python 3.6 or higher. Check your Python version:
```bash
python3 --version
```
3.  **No Additional Dependencies**: The program uses only the Python standard library (os and argparse), so no additional packages are needed.

## Usage

1.  **Prepare a Tree Diagram File**: Create a text file (e.g., structure.txt) containing the tree diagram. Use / to denote directories and # for optional comments. Example:
```bash
  my-project/
  ├── src/
  │   ├── main.py          # Main application
  │   └── utils/
  │       └── helper.py    # Helper functions
  ├── tests/
  │   └── test_main.py     # Unit tests
  ├── README.md            # Project documentation
  └── requirements.txt     # Dependencies
```

2.  **Run the Program**: Use the command-line interface to specify the tree diagram file and output directory:
```bash
python3 create_tree_structure.py <tree_file> <output_dir>
```
Example:
```bash
python3 create_tree_structure.py structure.txt ./my_project
```

3.  **Verify the Output**: Check the created structure using the tree command (install with sudo apt install tree on Debian-based systems or equivalent):
```bash
tree ./my_project
```
Expected output for the example above:
  ```bash
  ./my_project/my-project/
  ├── src/
  │   ├── main.py
  │   └── utils/
  │       └── helper.py
  ├── tests/
  │   └── test_main.py
  ├── README.md
  └── requirements.txt
```
## Example
For the following **structure.txt**:
  ```bash
  my-docker-project/
  ├── app/
  │   ├── __init__.py
  │   ├── main.py          # FastAPI application
  │   ├── static/          # Static files (CSS, JS, images)
  │   │   ├── style.css
  │   │   └── script.js
  │   ├── templates/       # HTML templates
  │   │   └── index.html
  │   ├── tts/             # TTS processing code
  │   │   ├── __init__.py
  │   │   └── processor.py # Wrapper for your CLI functionality
  │   └── models/          # Data models
  │       └── schemas.py
  ├── requirements.txt     # Project dependencies
  ├── Dockerfile           # For container deployment
  ├── README.md            # Project documentation
  └── .env                 # Environment variables
  ```

Run:
```bash
python3 create_tree_structure.py structure.txt ./mydockerproject
```
### Generating tree structure
1.  You may generate tree structure from your existing project.
```bash
sudo apt install tree
```
2.  To generate tree from command of a directory like: testproj.
```bash
tree ./testproj
```
OR use any AI based chat to generate teh project structure for you.

This creates the structure in ./mydockerproject/my-docker-project/ with all directories and files, ignoring comments after #.
Notes

*  File Names: The program strips comments (text after #) to ensure valid file and directory names. For example, main.py # FastAPI application becomes main.py.
*  Empty Files: Created files are empty. Populate them manually or extend the program to add content.
*  Tree Format: The program expects a tree diagram with │, ├, └, ─ characters and / for directories, as generated by the tree command.
*  Error Handling: The program validates the input file and handles common errors, such as missing files or invalid paths.

Contributing
Contributions are welcome! To contribute:

**Fork the repository**.
1.  Create a feature branch (git checkout -b feature/my-feature).
2.  Commit your changes (git commit -m "Add my feature").
3.  Push to the branch (git push origin feature/my-feature).
4.  Open a pull request.

Please include tests and update documentation as needed.
License
This project is licensed under the MIT License. See the LICENSE file for details.
Contact
For questions or suggestions, open an issue or contact the maintainer at [exoduxnile@gmail.com].
